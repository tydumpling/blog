![59d2c9913cb05eb63e200f1602f2247e](https://cdn.jsdelivr.net/gh/tydumpling/Picgo/img59d2c9913cb05eb63e200f1602f2247e.jpg)

```
这道题就是在源码环境里边如何来裁剪代码，就是有些没太用过的代码我们要裁剪掉，其实有很多现成的库可以做，一个是eslint和terser这两个库
eslint呢是在原码环境里边就可以进行检测，terser呢需要打包过后，它可以自动去给你完成一些裁剪，eslint他们两个都能做到啊。
他们的做法呢就是把你的源码文件读出来，然后通过AST进行抽象语法树分析，找到那些没有在本模块里边没有用到的东西。
然后呢给你做提示，或者是直接给你裁剪掉。啊但这两个的局限呢是啥？呢它是只能针对那个 Js文件，然后呢他只能是单模块，如果说你这个工程里面肯定不止单模块，啊肯定有很多很多的模块是吧。
比方这个模块导出了，另一个模块没用，他是发现不了的，它只能看这个模块里边你定义的东西，然后呢你有没有用它，懂这意思吧。
它只能针对单模块，啊这是第一个环境。然后呢第二个呢是针对多模块的呢叫上升到那个构建工具了，那构建工具有很多了，像什么rollup里边也有？vite里面也有
还包括webpack里边的更不要说了，啊一定是有的，它都有这么一个功能，啊叫做tree shaking叫树遥优化。

那么这个东西它是用来干嘛的？它就来针对多模块的，就是你这个模块导出了，但是呢另一个模块没有用它，其他的模块都没有用它导出的东西，那么它是能够分析得出来的。
因为它是把整个工程里边一起来进行分析的，它是能够发现这些导出，但是呢并没有使用的一些功能。
它能够发现它，然后呢给它优化掉，在打包的时候就自动完成了，这些东西都不需要你做任何事情。
就上面这个东西呢可能需要你做一些配置，下面的东西呢基本上不需要你做任何事情啊它都是自动完成的，不过呢这个东西呢也有缺陷啊也不算缺陷。
吧它有一个特点就是它只能支持js，css他不支持了啊。js TS因为TS编译过后也是jS嘛，然后呢它必须是esm的模块化标准，如果说，你动态导入是不行的，比方说你用一种require或者是用那个es的import动态导入那是不行的，因为它是静态分析，啊它只能在编译时态进行静态分析，动态的他搞不定啊就是这个问题。
呃如果说你希望支持那个commonJS的话，那么你需要去自行去编写一些东西，啊至于比方webpack的插件
啊或者是我看网上以前还有一个插件，别人编写的，现在不知道有没有在维护，啊好像很久没维护了。
它就是针对commonJS呢也进行了树遥优化，不过这里边问题很多，因为commonjs毕竟是一个动态模块化语言，有的时候呢根本就分析不出来倒入了啥好。
如果说，你要针对css的话你要使用那个purgecss，啊就使用这个了，这个我用来干嘛的，呢它是能够发现整个工程里边你的样式里边哪些类。
在页面里边没有用到，比方说一个html，比方说vue的单文件组件里边？
是不是可以写那个样式代码？啊可以使用一些类，那么它可以对整个工程呢进行分析，找到了一些没有被应用的类。
那么这些东西呢就是无效代码，啊就是没有被应用的代码，这就是purgecss它会把它裁剪掉。
他是专门在针对CsS的，啊他对jS是无效的。那么剩下一种情况呢就是前面三种东西呢可能没有彻底的解决你的问题，特别是像一些陈旧的工程或者是比较大的工程。
里边那里边乱七八糟的情况太多太多了，他可能有一些东西呢没有解决你的问题，那么剩下的事情呢就需要你自己去写了。
那么这学期写的前提条件是啥？呢就是你得懂工程化，啊咱们前端的话其实没有太多深入的东西，说实话。
有一些分支方向，比方说像nodejS啊啊或者是像做可视化呀或者是做那个多媒体啊或者gis。
方向一些分支方向，呢可能有一些深入的东西，就是主线上啊没有太多深的东西。
主线上就一个比较深入的东西，就是工程化，工程化你花个一两个月，吧你基本上就把工程化学完了
这里面就涉及到前处理合后处理器以及原子化都在里边。
啊前端工具链，这里边会涉及到eslint进程以及自定义eslint的插件以及prettier以及自定义babel插件。
terser swc这些东西
```

# 代码裁剪技术与工具总结

## 一、单模块代码裁剪工具
### 1. ESLint
- **功能**  
  通过AST抽象语法树分析，识别未使用的变量、函数及代码块。
- **优点**  
  - 灵活配置规则（如`no-unused-vars`）
  - 支持自定义插件扩展检测能力
- **缺点**  
  - 仅限单模块分析
  - 需要手动修复或集成到CI/CD流程

### 2. Terser
- **功能**  
  打包时自动移除死代码（需配合构建工具使用）
- **优点**  
  - 直接输出精简代码
  - 支持压缩混淆
- **缺点**  
  - 依赖AST静态分析，无法处理动态引用
  - 单模块局限性同ESLint

## 二、多模块代码裁剪方案
### Tree Shaking（树摇优化）
| 构建工具 | 支持程度 | 关键特性              |
| -------- | -------- | --------------------- |
| Webpack  | 🟢🟢🟢🟢🟢    | 内置支持ESM模块       |
| Vite     | 🟢🟢🟢🟢     | 原生支持TS/JS模块优化 |
| Rollup   | 🟢🟢🟢      | 专注模块化打包        |

#### 实现原理
1. 静态分析依赖图
2. 移除未被任何入口引用的导出内容
3. 要求：
   - 使用`import/export` ESM语法
   - 避免动态导入（`require()`/`import()`）

#### 局限性
- CommonJS模块需额外配置（如`webpack-node-externals`）
- 动态作用域变量无法被分析（如`window`对象属性）

## 三、CSS代码裁剪方案
### PurgeCSS
- **工作流程**  
  1. 收集所有HTML/CSS中的类名
  2. 分析源码中的CSS定义
  3. 删除未匹配的样式规则
- **典型配置**（Vite）：
  ```javascript
  // vite.config.js
  export default {
    css: {
      preprocessorOptions: {
        scss: { purge: ['./index.html'] }
      }
    }
  }

## 四、工程化进阶方向
### 必要技能栈
1. **构建工具链**  
   - 预处理器：Babel（转译TS/JSX）
   - 后处理器：Terser（代码压缩）
   - 原子化构建：按需加载模块

2. **质量保障体系**  
   ```javascript
   // ESLint配置示例
   module.exports = {
     extends: ['eslint:recommended'],
     rules: {
       'no-unused-vars': 'warn',
       '@typescript-eslint/no-unused-vars': 'off' // TS项目可关闭
     }
   };
   ```

### 进阶工具箱
| 工具                    | 核心用途            | 典型场景         |
| ----------------------- | ------------------- | ---------------- |
| Webpack Bundle Analyzer | 可视化依赖体积      | 优化第三方库引入 |
| Swc                     | 更快的Babel替代方案 | 大型项目构建加速 |
| Cost-of-Dependencies    | 量化npm依赖成本     | 依赖库版本治理   |

## 五、实施建议
1. **渐进式优化策略**  
   - 优先处理ESLint警告
   - 启用构建工具默认优化选项
   - 定期使用`webpack-bundle-analyzer`分析包体积

2. **监控机制**  
   ```bash
   # 持续检测未使用代码
   npm run eslint --watch src/
   ```
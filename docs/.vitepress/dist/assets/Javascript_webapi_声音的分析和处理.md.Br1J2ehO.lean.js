import{_ as i,c as a,a2 as e,o as n}from"./chunks/framework.DN5Ma_nw.js";const E=JSON.parse('{"title":"声音的分析和处理","description":"","frontmatter":{},"headers":[],"relativePath":"Javascript_webapi/声音的分析和处理.md","filePath":"learn/Javascript/webapi/声音的分析和处理.md","lastUpdated":1733132188000}'),t={name:"Javascript_webapi/声音的分析和处理.md"};function l(h,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="声音的分析和处理" tabindex="-1">声音的分析和处理 <a class="header-anchor" href="#声音的分析和处理" aria-label="Permalink to &quot;声音的分析和处理&quot;">​</a></h1><h2 id="效果展示" tabindex="-1">效果展示 <a class="header-anchor" href="#效果展示" aria-label="Permalink to &quot;效果展示&quot;">​</a></h2><p>现有一个需求：在用户播放音频文件时，有相应的声波动画效果，如下图所示：</p><p><img src="https://pic.imgdb.cn/item/65338863c458853aefa5efc0.gif" alt="音频播放效果" loading="lazy"></p><h2 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h2><p>首先需要了解 <code>audio.api</code> 的相关知识，请注意，这不是写一个 <code>audio</code> 标签调用 <code>play()</code> 方法，这个方法是专门处理音频数据的。</p><p>想要了解这个 API 方法，需要了解两个核心概念：</p><ol><li>音频上下文 <code>AudioContent</code> （即所有节点的集合，是一个环境，用于管理节点）</li><li>处理节点（即处理音频数据的环节）</li></ol><h3 id="requestanimationframe" tabindex="-1">requestAnimationFrame() <a class="header-anchor" href="#requestanimationframe" aria-label="Permalink to &quot;requestAnimationFrame()&quot;">​</a></h3><p><strong><code>window.requestAnimationFrame()</code></strong> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><blockquote><p><strong>备注：</strong> 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 <code>requestAnimationFrame()</code>。<code>requestAnimationFrame()</code> 是一次性的。</p></blockquote><p>当你准备更新在屏动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数（即你的回调函数）。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，在大多数浏览器里，当 <code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noreferrer">\`\`</a> 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noreferrer"><code>DOMHighResTimeStamp</code></a> 参数会传入回调方法中，它指示当前被 <code>requestAnimationFrame()</code> 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位为毫秒，最小精度为 1ms（1000μs）。</p><p><strong>警告：</strong> 请确保总是使用第一个参数（或其他一些获取当前时间的方法）来计算动画在一帧中的进度，<strong>否则动画在高刷新率的屏幕中会运行得更快</strong>。请参考下面示例的做法。</p><p>语法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback)</span></span></code></pre></div><p>参数</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame#callback" target="_blank" rel="noreferrer"><code>callback</code></a></p><p>当你的动画需要更新时，为下一次重绘所调用的函数。该回调函数会传入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noreferrer"><code>DOMHighResTimeStamp</code></a> 参数，该参数与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now" target="_blank" rel="noreferrer"><code>performance.now()</code></a> 的返回值相同，它表示 <code>requestAnimationFrame()</code> 开始执行回调函数的时刻。</p></li></ul><p>返回值</p><p>一个 <code>long</code> 整数，请求 ID，是回调列表中唯一的标识。是个非零值，没有别的意义。你可以传这个值给 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame" target="_blank" rel="noreferrer"><code>window.cancelAnimationFrame()</code></a> 以取消回调函数请求。</p><h3 id="audiocontext-createanalyser" tabindex="-1">AudioContext.createAnalyser() <a class="header-anchor" href="#audiocontext-createanalyser" aria-label="Permalink to &quot;AudioContext.createAnalyser()&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext" target="_blank" rel="noreferrer"><code>AudioContext</code></a>的<code>createAnalyser()</code>方法能创建一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AnalyserNode" target="_blank" rel="noreferrer"><code>AnalyserNode</code></a>，可以用来获取音频时间和频率数据，以及实现数据可视化。</p><p>语法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AudioContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> analyser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createAnalyser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>返回值</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AnalyserNode" target="_blank" rel="noreferrer"><code>AnalyserNode</code></a>对象</p><h3 id="analysernode-fftsize" tabindex="-1">AnalyserNode.fftSize <a class="header-anchor" href="#analysernode-fftsize" aria-label="Permalink to &quot;AnalyserNode.fftSize&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AnalyserNode" target="_blank" rel="noreferrer"><code>AnalyserNode</code></a> 接口的 <code>fftSize</code> 属性的值是一个无符号长整型的值，表示（信号）样本的窗口大小。当执行<a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noreferrer">快速傅里叶变换</a>（Fast Fourier Transfor (FFT)）时，这些（信号）样本被用来获取频域数据。</p><p><code>fftSize</code> 属性的值必须是从 32 到 32768 范围内的 2 的非零幂; 其默认值为 2048.</p><blockquote><p><strong>备注：</strong> 如果其值不是 2 的幂，或者它在指定范围之外，则抛出异常 INDEX_SIZE_ERR.</p></blockquote><p>语法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AudioContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> analyser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createAnalyser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">analyser.fftSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2048</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>值</p><p>一个无符号长整型。</p><h3 id="analysernode-getbytefrequencydata" tabindex="-1">AnalyserNode.getByteFrequencyData() <a class="header-anchor" href="#analysernode-getbytefrequencydata" aria-label="Permalink to &quot;AnalyserNode.getByteFrequencyData()&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AnalyserNode" target="_blank" rel="noreferrer"><code>AnalyserNode</code></a>接口的 <strong><code>getByteFrequencyData()</code></strong> 方法将当前频率数据复制到传入的 Uint8Array（无符号字节数组）中。</p><p>如果数组的长度小于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AnalyserNode/frequencyBinCount" target="_blank" rel="noreferrer"><code>AnalyserNode.frequencyBinCount</code></a>, 那么 Analyser 多出的元素会被删除。如果是大于，那么数组多余的元素会被忽略。</p><p>语法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AudioContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> analyser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createAnalyser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(analyser.frequencyBinCount); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Uint8Array 的长度应该和 frequencyBinCount 相等</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">analyser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getByteFrequencyData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dataArray); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 getByteFrequencyData 方法填充 Uint8Array</span></span></code></pre></div><p>返回值</p><p>一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" target="_blank" rel="noreferrer"><code>Uint8Array</code> (en-US)</a>（无符号字节数组）.</p><h2 id="效果实现" tabindex="-1">效果实现 <a class="header-anchor" href="#效果实现" aria-label="Permalink to &quot;效果实现&quot;">​</a></h2><p>这个效果，是通过 <code>canvas</code> 画布画一个圆，然后通过绘制线的长度即可实现效果，如下图所示：</p><p><img src="https://pic.imgdb.cn/item/65339234c458853aefc6455d.jpg" alt="初步效果" loading="lazy"></p><p>现在重点是如何获取音频的数据。需要先点击 <code>audio</code> 标签才能播放音频，因此去监听其播放事件，监听事件做以下几件事情：</p><ol><li>判断变量是否初始化，如果已经初始化则返回，不用再创建</li><li>创建音频上下文</li><li>使用 <code>createAnalyser()</code> 方法创建一个音频分析器节点</li><li>调用 <code>getByteFrequencyData(数组)</code> 方法，该方法可以获取附近一小段时间内音频的频率，因此需要不断调用该方法，把该方法提取出去。最后分析出来的结果会放到括号内的数组里</li><li>调用 <code>fftSize</code> 属性控制音频获取的频率精细程度</li><li>使用 <code>createMediaElementSource()</code> 方法建立音频来源节点</li><li>连接音频来源节点和音频分析节点</li><li>初始化变量设置为 <code>true</code></li><li>最后拓展完善，把音频频率数组空的部分去掉，再通过计算让其视觉效果连贯</li></ol><p>代码如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isInit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 是否初始化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> analyser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">buffer</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">audioElm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onplay</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果已经初始化则不用继续往下执行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isInit) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建音频上下文</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> audioCtx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AudioContent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建分析节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    analyser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createAnalyser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    analyser.fftSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 512</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建保存音频频率的数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uinit8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(analyser.frequencyBinCount)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 建立音频来源的信息，连接音频来源节点和音频分析节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createMediaElementSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(audioElm)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(analyser)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 音频播放连接到喇叭，播放给用户听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    analyser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(audioCtx.destination)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(update)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isInit) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    analyser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getByteFrequencyData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 稍做处理，把音频数组内部分空的部分去除掉；并让数组整体长度为2倍，保存时对应首尾都保存，做对称保存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> offest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> datas</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(offest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offest; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        datas[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> datas[datas.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buffer[i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h2 id="拓展-获取麦克风数据" tabindex="-1">拓展：获取麦克风数据 <a class="header-anchor" href="#拓展-获取麦克风数据" aria-label="Permalink to &quot;拓展：获取麦克风数据&quot;">​</a></h2><p>实际上 <code>createMediaElementSource()</code> 方法连接音频数据来源不仅仅可以连接 <code>audo</code> 标签的音频来源，也可以连接用户的麦克风数据。</p><p>基本步骤如下：</p><ol><li>调用内置 API 方法 <code>navigator.mediaDevices.getUserMedia()</code> 获取麦克风数据（如果是第一次使用需要事先获取用户的麦克风权限）</li><li>修改音频来源连接方法 <code>createMediaElementSource()</code> 的参数为麦克风</li></ol><p>修改后的代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> audioCtx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createMediaElementSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stream)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(analyser)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // analyser.connect(aduioCtx.destination)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    isInit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span></code></pre></div>`,54)]))}const c=i(t,[["render",l]]);export{E as __pageData,c as default};

import{_ as i,c as a,a2 as e,o as t}from"./chunks/framework.DN5Ma_nw.js";const r=JSON.parse('{"title":"运用前瞻实现密码强度检测","description":"","frontmatter":{},"headers":[],"relativePath":"Reg/do/运用前瞻实现密码强度检测.md","filePath":"learn/Reg/do/运用前瞻实现密码强度检测.md","lastUpdated":1733132188000}'),p={name:"Reg/do/运用前瞻实现密码强度检测.md"};function n(h,s,l,k,d,c){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="运用前瞻实现密码强度检测" tabindex="-1">运用前瞻实现密码强度检测 <a class="header-anchor" href="#运用前瞻实现密码强度检测" aria-label="Permalink to &quot;运用前瞻实现密码强度检测&quot;">​</a></h1><p>有一个要求，需要设置一个正则检测密码强度，要求有两点：</p><ol><li>密码 6-12 位</li><li>必须包含数字、大小写字母、特殊字符</li></ol><p>咋一看很简单，直接用 <code>[]</code> 包含以及 <code>{6,12}</code> 设置长度即可，代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[0-9a-zA-Z@!$_]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">{6,12}$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span></code></pre></div><p>但是这并不是正确的写法，如果这么写，全是数字的密码也能通过校验。因为上方规则表示任选其一。</p><p>想要实现要求，需要使用到前瞻运算。正则匹配实际上是规则和字符串一起移动来匹配，如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">abc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">abc</span></span></code></pre></div><p>首先匹配正则的开始标识 <code>^</code> ，字符串的匹配指针为字母 <code>a</code> 前面；然后正则往后一位匹配到 <code>a</code> ，字符串匹配指针也往后一位到字母 <code>a</code> ；正则往后一位到 <code>b</code> ，字符串匹配指针也往后一位到字母 <code>b</code> ......直到最后匹配完毕。</p><p>但如果把匹配规则改一下，使用前瞻（也就是正向预查）就无法匹配了。代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">(?=a)bc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">abc</span></span></code></pre></div><p>正则匹配到前瞻时不会消耗字符，首先匹配正则的开始标识 <code>^</code> ，字符串的匹配指针为字母 <code>a</code> 前面；然后正则往后一位匹配到前瞻 <code>(?=a)</code> ，而字符串的匹配指针不会跟着往后移动。因此匹配不成功。</p><p>那他有什么好处呢？可以在匹配的时候先不着急消耗字符串往后匹配，而是先往后看看是否满足规则。用上方的要求来说，利用前瞻不消耗的特性在最开始看后续有没有大小写字母、数字、特殊字符。</p><p>修改后写法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">(?=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[0-9]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)(?=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[a-z]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)(?=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[A-Z]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)(?=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[@!$_]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">{6,12}$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span></code></pre></div><p>现在就能够实现密码强度检测了。</p>`,16)]))}const F=i(p,[["render",n]]);export{r as __pageData,F as default};

import{_ as e,c as l,a2 as i,o as p}from"./chunks/framework.DN5Ma_nw.js";const u=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"Javascript/markdown/事件循环.md","filePath":"learn/Javascript/markdown/事件循环.md","lastUpdated":1733132188000}'),t={name:"Javascript/markdown/事件循环.md"};function o(r,a,s,n,h,d){return p(),l("div",null,a[0]||(a[0]=[i(`<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><p>要讲事件循环，首先要把它前因后果都要讲清楚：浏览器的进程模型。因为这个事件循环跟浏览器是密切相关的，浏览器要执行JS，它的关联是浏览器里边的东西，它是跟浏览器密切相关的。了解浏览器，要讲这个浏览器的进程模型。</p><h2 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to &quot;进程&quot;">​</a></h2><p>啥叫进程？</p><p>一个程序，像QQ，微信，王者荣耀，他们都属于程序，程序运行需要啥，它需要内存空间。为什么？程序里边不得有变量吗，不得有对象吗，不得有函数吗，这些东西哪个不是放到内存里边的是吧，所以它需要有一块自己专属的内存空间，分配给你一块。不够了，再说我给你扩容。</p><p>于是程序运行它需要有一块专属内存空间，你可以把简把进程简单的理解为就是这块内存空间，有这块内存空间就是进程，那么每一个程序呢，一启动的时候至少得有一个进程，也就是至少得有一块空间嘛，对吧，而且进程与进程之间呢，是相互独立的，就内存空间之间是隔离的，</p><p>例如QQ、微信和王者荣耀，他们的内存呢，有的多有的少，但是他们的内存有没有交叉，不可能交叉的，交叉的话就变成共享，变成共用了，它要出大问题。为什么呢？因为进程之所以这样设计，它的目的就是为了隔离。</p><p>隔离的好处在什么呢，QQ里自己出了问题了，比方内存空间里面乱了套了，自己崩溃了，不会影响到微信，不会影响到你玩那个王者荣耀。</p><p>那么进程之间它是相互隔离的，那他们之间能不能通信呢，就比方说QQ里边想用微信里边的东西能不能用呢，不是说完全不行，只要你想要，他愿意给就行，是吧，即使要通信，也需要双方同意。</p><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><p>进程搞清楚了之后呢，接着来看线程。为什么要说线程呢，因为这两个玩意就是密不可分的，进程说完了说线程，你才能理解浏览器的进程模型，你理解了浏览器的进程模型，才知道事件循环发生在哪个位置，然后呢，才能去讲这个时间循环。有了进程之后，他有了内存空间了，就可以运行程序的代码了。</p><p>那么问题是谁来运行代码呢？运行代码的那个人，我们把它类比于人，有个人在读这个代码，在跑，在运行那个代码，那个人呢，我们就可以把它简单的称为线程，所以说一个进程，它至少得有一个线程，为啥呢，不然的话给你分配块内存空间，你又不干活，你不中用，你有啥用，我赶快就把你给你消灭掉了，把这个进程给杀死，我们把进程退出进程叫做杀死进程。你们用了，给你内存空间给你回收掉了。</p><p>因为咱们现实世界里边呢，倒是有一些空置房没人住，但是在计算机里边不行，计算机里边内存是寸土寸金，给到你，你就必须要干活，你没有人运行代码，那么给了你的内存空间不是瞎给吗，所以呢，一个进程至少得有一个线程去干活，去运行代码，因此在进程启动的时候，就会自动的创建一个线程来运行代码，那么这个线程呢，我们把它称之为主线程，就是跟随着进程启动的时候产生的线程。</p><p>另外一个小的知识点，大家了解一下，如果说主线程结结束了，整个层皮就结束了，好这个了解一下就行了。</p><p>但是很多程序呢，它比较复杂，它可能需要同时的执行多块代码，比方说什么王者荣耀，对吧，他要做很多事儿，他要监听你的各种操作，要让人物的跟随你的操作来移动，还要进行网络通信，看别人是咋操作的，对吧，都是需要网络的，这么多事情要做，可能一个人呢，他忙不过来，于是呢，主线程，他忙不过来的时候，他就会想办法，他想什么办法呢，就多招点人，会启动更多的线程来执行代码。一个进程可以包含多个线程。</p><h2 id="进程模型" tabindex="-1">进程模型 <a class="header-anchor" href="#进程模型" aria-label="Permalink to &quot;进程模型&quot;">​</a></h2><p>了解上方两个概念后，就可以了解进程模型这个概念了。浏览器中，内部工作及其复杂，为了避免相互影响，为了减少连环崩溃几率，当启动浏览器后，它会自动启动多个进程。</p><blockquote><p>浏览器是一个多进程多线程的应用程序。可以通过浏览器的任务管理器中查看当前所有进程。</p></blockquote><p>主要分为三个进程：</p><ul><li>浏览器进程</li><li>网络进程</li><li>渲染进程</li></ul><p>这样一个进程崩溃了，也不会影响到另外的进程。</p><h3 id="浏览器进程" tabindex="-1">浏览器进程 <a class="header-anchor" href="#浏览器进程" aria-label="Permalink to &quot;浏览器进程&quot;">​</a></h3><p>浏览器进程主要负责界面显示（浏览器标题等）、用户点击交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p><h3 id="网络进程" tabindex="-1">网络进程 <a class="header-anchor" href="#网络进程" aria-label="Permalink to &quot;网络进程&quot;">​</a></h3><p>负责加载网络资源，如图片等。网络进程内部会启动多个线程来处理不同的网络任务。</p><h3 id="渲染进程-重点" tabindex="-1">渲染进程（重点） <a class="header-anchor" href="#渲染进程-重点" aria-label="Permalink to &quot;渲染进程（重点）&quot;">​</a></h3><p>渲染进程启动后，会开启一个渲染主线程。主线程负责执行 HTML 、CSS、JS代码。默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同标签页之间不相互影响。</p><blockquote><p>将来该默认模式可能会有所改变，有兴趣的可以去谷歌官网文档查看说明</p></blockquote><p>渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画60次（FPS 帧率）</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>......</li></ul><p>如果主线程遇到一个任务，该如何调度？</p><p>渲染主线程想出了一个新的方法：排队。主要做以下操作：</p><ol><li><p>在最开始的时候，渲染主线程会进入一个无限循环</p><p>渲染主线程的启动源码是用 C++ 写的，他是这么写的：</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ;; ) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ....</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>条件永远为真，就能进入无限循环。他每一次循环做了很多事情，如从消息队列里拿下一个任务。</p></li><li><p>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环。如果没有，则进入休眠状态</p></li><li><p>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务，新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒继续循环拿去任务</p></li></ol><h2 id="其他细节" tabindex="-1">其他细节 <a class="header-anchor" href="#其他细节" aria-label="Permalink to &quot;其他细节&quot;">​</a></h2><p>事件循环到此已经说明完毕了，但还是不够，事件循环里面的细节也需要解释一下，事件循环会有更多的理解。</p><h3 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h3><p>代码在执行过程中，会遇到一些 <em>无法立即处理的任务</em> ，比如：</p><ul><li>计时完成后需要执行的任务 —— <code>setTimeout</code> 、<code>setInterval</code></li><li>网络通信完成后需要执行的任务 —— <code>XHR</code> 、<code>Fetch</code></li><li>用户操作后需要执行的任务 —— <code>addEventListener</code></li></ul><p>如果让 <em>渲染主线程</em> 等待这些任务的时机达到，就会导致主线程长期处于 “阻塞” 的状态，从而导致浏览器 “卡死” 。</p><p><strong>渲染主线程承担着及其重要的工资，无论如何不能阻塞！</strong></p><p>因此，浏览器选择异步来解决这个问题。使用异步方式，<strong>渲染主线程永不阻塞</strong> 。</p><blockquote><p>如何理解 JS 异步？</p><p>JS 是单线程语言，这是因为它运行在浏览器的渲染主线程中。而渲染主线程只有一个。</p><p>但是渲染主线程承担很大工资，如渲染页面、执行 JS 操作等，如果使用同步的方式，就有可能造成主线程阻塞，导致消息队列中很多任务无法得到执行。一方面导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免，具体做法是当某些任务发生时，比如定时器、事件监听等，主线程将任务交给其他线程执行处理，自身立即结束任务执行，转而执行后续代码。当其他线程完成后，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p></blockquote><h3 id="js阻碍渲染" tabindex="-1">JS阻碍渲染 <a class="header-anchor" href="#js阻碍渲染" aria-label="Permalink to &quot;JS阻碍渲染&quot;">​</a></h3><p>因为 JS 和渲染线程都在浏览器的渲染主线传上，执行 JS 时，渲染只能等待，直到 JS 渲染完毕。因此如果 JS 代码执行时间过长，会有阻碍渲染的麻烦。</p><h3 id="任务优先级" tabindex="-1">任务优先级 <a class="header-anchor" href="#任务优先级" aria-label="Permalink to &quot;任务优先级&quot;">​</a></h3><p>任务没有优先级，在消息队列中先进先出。但是 <strong>消息队列是有优先级的</strong> 。</p><p>根据 W3C 最新解释是这么说的：</p><ul><li>每个任务都有一个任务类型，同一个任务类型必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行</li></ul><p>在目前 chrome 的实现中，至少包含下面的队列：</p><ul><li>延时队列：用于存放计时器，优先级 中</li><li>交互队列：用于存放用户交互后的函数，优先级 高</li><li>微队列：用户存放需要最快执行的任务，优先级 最高</li></ul><blockquote><p>添加任务到微队列的主要方式为使用 <code>Promise</code> 、<code>MutationObserver</code></p></blockquote><p>浏览器还有很多其他队列，但是和我们开发关系不大，不做考虑。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>浏览器的进程模型，描述浏览器在启动后，它会开启多个进程，原因是为了隔离，避免一个进程的功能运行崩溃了之后影响到其他进程。隔离之后，一个进程崩溃不会影响到别人。</p><p>其次重点讲了渲染进程，特别是渲染进程里边的主线程叫做渲染主线程，因为渲染主线程承担的事情太多了，因此，他找到了一种方式来解决事情混乱的问题，排队。</p><p>这些事情一件一件处理，不要同时处理几件，人都是单线程的，这样使用一个队列的方式，把一个任务一个任务取出来执行，执行完了之后再取下一个，这就是事件循环，实际上它本质上呢，就是用了一个无限的循环，每一次循环取一个任务执行，执行完了取下一个，下一次循环取下一个。</p><p>那么这个事件循环呢，其实跟异步就有关系，如果说我们使用同步的方式呢，就会造成阻塞，而用这种事件循环的方式，把任务加到排队，列边排队，就不会有这个阻塞的问题</p><ul><li>事件循环是异步的实现方式</li><li>单线程是异步产生的原因</li></ul><p>有了异步之后，线程永不阻塞，我们的整个浏览器的运行呢，就非常流畅了，然后我们在事件循环里边实际上使用了多个队列，有微队列，有延时队列，有交互队列，最先执行的一定是微队列，每一次取任务的时候，优先从微队列里面去取，取完了之后再去看其他队列。</p><p>在延时队列和交互队列这一块呢，目前来讲是交互队列优先区，然后延时队列的后区，那将来会怎么样不知道，但一定是微队列首先区，它的优先级是最高的。</p>`,60)]))}const k=e(t,[["render",o]]);export{u as __pageData,k as default};

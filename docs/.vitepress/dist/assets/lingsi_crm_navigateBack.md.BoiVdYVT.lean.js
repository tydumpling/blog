import{_ as s,c as i,a2 as e,o as t}from"./chunks/framework.DN5Ma_nw.js";const d=JSON.parse('{"title":"navigateBack 传参","description":"","frontmatter":{},"headers":[],"relativePath":"lingsi/crm/navigateBack.md","filePath":"project/lingsi/crm/navigateBack.md","lastUpdated":1733132188000}'),n={name:"lingsi/crm/navigateBack.md"};function p(l,a,h,k,r,g){return t(),i("div",null,a[0]||(a[0]=[e(`<h1 id="navigateback-传参" tabindex="-1">navigateBack 传参 <a class="header-anchor" href="#navigateback-传参" aria-label="Permalink to &quot;navigateBack 传参&quot;">​</a></h1><p>根据官方文档显示，wx.navigateBack() 方法是不支持传参的，因此如果需要返回上一页对数据做某种处理时，可以使用 getCurrentPages() 方法。</p><h2 id="getcurrentpages" tabindex="-1">getCurrentPages <a class="header-anchor" href="#getcurrentpages" aria-label="Permalink to &quot;getCurrentPages&quot;">​</a></h2><p>获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。</p><blockquote><p>注意： 不要尝试修改页面栈，会导致路由以及页面状态错误。</p></blockquote><p>不要在 <code>App.onLaunch</code> 的时候调用 <code>etCurrentPages</code>，此时 <code>page</code> 还没有生成。 获取到需要的页面（即上一页）： <code>let prevPage = page[page.length - 2]</code> 此时 <code>prevPage</code> 代表的就是上一页的实例，相当于 <code>this</code> 。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCurrentPages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取当前页面栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page[page.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//代表的就是上一页的实例，相当于this</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prevPage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  list: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">navigateBack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  delta: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>现在就可以对该页面的数据做操作再返回上一页了。</p><blockquote><p>拓展 <a href="https://blog.csdn.net/shadow_zed/article/details/104387841/" target="_blank" rel="noreferrer">getCurrentPages的一些坑点</a></p></blockquote>`,9)]))}const o=s(n,[["render",p]]);export{d as __pageData,o as default};

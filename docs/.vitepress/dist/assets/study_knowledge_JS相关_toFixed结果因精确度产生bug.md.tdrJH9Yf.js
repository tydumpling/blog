import{_ as i,c as a,a2 as t,o as e}from"./chunks/framework.DN5Ma_nw.js";const g=JSON.parse('{"title":"toFixed结果因精确度产生bug","description":"","frontmatter":{},"headers":[],"relativePath":"study/knowledge/JS相关/toFixed结果因精确度产生bug.md","filePath":"learn/study/knowledge/JS相关/toFixed结果因精确度产生bug.md","lastUpdated":1733132188000}'),h={name:"study/knowledge/JS相关/toFixed结果因精确度产生bug.md"};function p(n,s,l,k,d,r){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="tofixed结果因精确度产生bug" tabindex="-1">toFixed结果因精确度产生bug <a class="header-anchor" href="#tofixed结果因精确度产生bug" aria-label="Permalink to &quot;toFixed结果因精确度产生bug&quot;">​</a></h1><h2 id="前情提要" tabindex="-1">前情提要 <a class="header-anchor" href="#前情提要" aria-label="Permalink to &quot;前情提要&quot;">​</a></h2><p>在项目中有一个奇怪的现象，代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toFixed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2.5</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.45</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toFixed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2.5</span></span></code></pre></div><p>可以看到，<code>toFixed</code> 返回的结果是错误的。这是因为计算机计算浮点数存在精度错误的情况。</p><p>如果想要深入了解，必须先了解为什么计算机会存在精度问题。</p><h2 id="精度问题" tabindex="-1">精度问题 <a class="header-anchor" href="#精度问题" aria-label="Permalink to &quot;精度问题&quot;">​</a></h2><p>计算机在以下三个方面都会有可能造成精度丢失。</p><h3 id="存储" tabindex="-1">存储 <a class="header-anchor" href="#存储" aria-label="Permalink to &quot;存储&quot;">​</a></h3><p>一个十进制的小数，计算机会将其转为二进制，然后再存储到内存中。</p><p>但是计算机字符是有长度限制的，当转为二进制后字符过长，计算机会做 <strong>舍入</strong> 处理。如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0011001100</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 010011</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 截取后的第一位是0，因此前面保留的最后一位填0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0011001101</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100110</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 截取后的第一位是1，因此前面保留的最后一位进1</span></span></code></pre></div><p>由此，在计算机中，下面这个等式是成立的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.20000000000000000001</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.19999999999999999999</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>由此可见，存储的时候可能会存在不精确的情况。</p><h3 id="计算" tabindex="-1">计算 <a class="header-anchor" href="#计算" aria-label="Permalink to &quot;计算&quot;">​</a></h3><p>计算机做计算使用的不是十进制，而是二进制。计算后得到的依旧是二进制，最终转为十进制的数显示在浏览器上。</p><p>下面看几个例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.300000000000000004</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span></span></code></pre></div><p>这是可能会有疑问，为什么 0.2 和 0.3 相加它的结果又精确了呢？这是因为有一些不精确它们会抵消掉。如 0.1 转为二进制最后会做入操作，0.2 转为二进制最后会做入操作.两个入因此最后结果会比原来的更大。0.3 转为二进制最后会做舍操作，和 0.2 相抵消，因此结果正常。</p><p>举一反三可以联想一下 0.3-0.2 的结果和 0.2-0.3 的结果，他们和原来的相比是更大还是更小呢？</p><p>0.3 是舍操作，0.2是入操作，0.3 - 0.2 是更小的被减数减去更大的减数，得出的差会比原来的更小；0.2 - 0.3 是更大的被减数减去更小的减数，得出的差会比原来的更大。检验一下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 0.0999999999999999998</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // -0.9999999999999999998</span></span></code></pre></div><h3 id="显示" tabindex="-1">显示 <a class="header-anchor" href="#显示" aria-label="Permalink to &quot;显示&quot;">​</a></h3><p>既然 0.2 存到计算机里会出现二进制精度转换问题，为什么 <code>console.log</code> 打印的时候能够正常打印出 0.2呢？</p><p>因为这是计算机做了近似匹配处理，计算机发现要打印的变量的二进制很相似 0.2，因此他会近似显示 0.2。而 0.1 + 0.2 的结果近似值与 0.3 的二进制相差甚远，因此最后没显示 0.3。</p><h2 id="tofixed本质" tabindex="-1">toFixed本质 <a class="header-anchor" href="#tofixed本质" aria-label="Permalink to &quot;toFixed本质&quot;">​</a></h2><p>回到最开始的问题，为什么 <code>toFixed</code> 出现问题，这是因为 <code>toFixed</code> 本质也是在做计算，计算后再显示结果。</p><p>把他们的值以指定的精度返回该数值对象的字符串，结果如下：</p><p><img src="https://pic.imgdb.cn/item/65fb05449f345e8d038ff942.png" alt="结果" loading="lazy"></p><p>因此最开始的问题也得到了解答。</p><h2 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h2><p>可以下载 <code>Decimal</code> 第三方库解决，其原理是在存储的时候不再存储数字，而是存字符串。在运算的时候循环字符串来做运算。</p><p>感兴趣可以去 github 阅读其源码 <a href="https://github.com/MikeMcl/decimal.js" target="_blank" rel="noreferrer">MikeMcl/decimal.js：JavaScript 的任意精度 Decimal 类型 (github.com)</a> 。</p>`,34)]))}const c=i(h,[["render",p]]);export{g as __pageData,c as default};

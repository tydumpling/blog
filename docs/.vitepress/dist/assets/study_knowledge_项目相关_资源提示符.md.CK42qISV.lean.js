import{_ as d,c,a2 as o,o as a}from"./chunks/framework.DN5Ma_nw.js";const h=JSON.parse('{"title":"资源提示符","description":"","frontmatter":{},"headers":[],"relativePath":"study/knowledge/项目相关/资源提示符.md","filePath":"learn/study/knowledge/项目相关/资源提示符.md","lastUpdated":1733132188000}'),t={name:"study/knowledge/项目相关/资源提示符.md"};function r(p,e,l,n,i,s){return a(),c("div",null,e[0]||(e[0]=[o('<h1 id="资源提示符" tabindex="-1">资源提示符 <a class="header-anchor" href="#资源提示符" aria-label="Permalink to &quot;资源提示符&quot;">​</a></h1><p>一个项目打包后的 <code>index.html</code> 会生成很多 <code>link</code> 和 <code>script</code> 标签链接。这些链接都会加上一些 <code>rel</code> 属性，比如 <code>rel=&quot;prefetch&quot;</code> 或者 <code>rel=&quot;preload&quot;</code>。这个 <code>prefetch</code> 和 <code>preload</code> 都被统称为资源提示符。</p><p>资源提示符不仅上面两个，还包括 <code>async</code> 、<code>defer</code> 、<code>preconnect</code> 、<code>prerender</code> 等。后两者不常见，这里不做介绍。</p><h2 id="async-和-defer" tabindex="-1">async 和 defer <a class="header-anchor" href="#async-和-defer" aria-label="Permalink to &quot;async 和 defer&quot;">​</a></h2><p>这两个资源提示符都是作用于 <code>script</code> 标签的。下面来对比一下不用两者提示符、分别使用两者提示符浏览器解析 <code>script</code> 标签的区别。</p><ul><li><p>正常情况 <img src="https://pic.imgdb.cn/item/67457006d0e0a243d4d1235d.png" alt="正常情况" loading="lazy"> 从上图可以看出，在啥提示符都不使用的情况下，浏览器会先正常解析 DOM元素。当看到 <code>script</code> 标签时会开启另一个网络线程下载相关 JS，在此期间它会一直等待，直到 JS 下载完成并执行。如果 JS 下载时间过长，那么页面渲染就会卡住，直到 JS 下载并执行完成。这就是页面堵塞。</p><p>因此在之前 <code>script</code> 标签都是放到 <code>body</code> 标签的底部，确保页面 DOM 元素渲染完毕后再执行。但是这样并不是最好的办法，因为 JS 下载时间过长，浏览器还是会需要一定时间去下载等待，因此这段堵塞时间还是需要优化。</p></li><li><p><code>async</code> 情况 <img src="https://pic.imgdb.cn/item/674571e9d0e0a243d4d12424.png" alt="async情况" loading="lazy"> 接着看添加 <code>async</code> 提示符后的情况。从上图可以看出，当浏览器遇到添加了 <code>async</code> 提示符的 <code>script</code> 标签时，会异步下载 JS 文件，此时页面的 DOM 渲染不会中断停止。直到 JS 请求完毕后再去执行该 JS 文件，执行完后继续渲染 DOM。</p><p>但是这种方式也有缺点，就是 JS 执行顺序无法保证。如果 JS 文件之间存在依赖关系，那么使用 <code>async</code> 提示符就会导致 JS 执行顺序混乱，从而报错。若该 JS 文件使用到了 DOM 元素，那么 DOM 元素可能还未渲染完毕，因此无法获取到对应 DOM 元素从而报错。</p></li><li><p><code>defer</code> 情况 <img src="https://pic.imgdb.cn/item/674572dfd0e0a243d4d124ad.png" alt="defer情况" loading="lazy"> 最后看 <code>defer</code> ，这个提示符和 <code>async</code> 提示符类似，都是异步下载 JS 文件。但是 <code>defer</code> 提示符会保证 JS 文件的执行顺序，并且 DOM 元素渲染完毕后再执行 JS 文件。因此 <code>defer</code> 提示符是解决页面堵塞最好的办法。</p><p>额外注意的是，添加了 <code>defer</code> 提示符的 JS 文件运行时间点是在触发 <code>DOMContentLoaded</code> 事件之前。</p></li></ul><h2 id="prefetch-和-preload" tabindex="-1">prefetch 和 preload <a class="header-anchor" href="#prefetch-和-preload" aria-label="Permalink to &quot;prefetch 和 preload&quot;">​</a></h2><p>这两个资源提示符都是作用于 <code>link</code> 标签的。二者都是预先加载资源，都不会影响 DOM 解析，二者主要的区别是优先级。</p><p><img src="https://pic.imgdb.cn/item/67457434d0e0a243d4d12521.png" alt="prefetch 和 preload执行顺序" loading="lazy"></p><p>如果使用的是 <code>preload</code> ，那么他的优先级是最高的，相当于告诉浏览器你要尽快下载完成，浏览器会优先加载该资源。</p><p>如果使用的是 <code>prefetch</code> ，那么他的优先级是较低的，相当于告诉浏览器这里有资源在你有空再下载就行，浏览器会在空闲时间才会去加载该资源。</p><p>因此当项目一开始需要下载的资源很多，而用户可能不会用到这些资源时，就可以使用 <code>prefetch</code> 提示符。</p>',12)]))}const m=d(t,[["render",r]]);export{h as __pageData,m as default};
